# The challenge

This is normal RSA except it give us 2 sensitive integer: 

- (p-2)*(q-1)
- (p-1)*(q-2)

From that we can easily recover p and q and calculate the private key.

I joined the AngstromCTF later so i check out in [factordb](http://factordb.com/index.php?query=125152237161980107859596658891851084232065907177682165993300073587653109353529564397637482758441209445085460664497151026134819384539887509146955251284230158509195522123739130077725744091649212709410268449632822394998403777113982287135909401792915941770405800840172214125677106752311001755849804716850482011237) if the n has been factorize, fortunately it has so i take the 2 factors and made a private key than decrypted as normal RSA.

This time i was lucky but not always so the implementation to solve this challenge is either using math or z3 in python. Here is the script:

```python
from z3 import * 

n = 125152237161980107859596658891851084232065907177682165993300073587653109353529564397637482758441209445085460664497151026134819384539887509146955251284230158509195522123739130077725744091649212709410268449632822394998403777113982287135909401792915941770405800840172214125677106752311001755849804716850482011237
e = 65537
c = 40544832072726879770661606103417010618988078158535064967318135325645800905492733782556836821807067038917156891878646364780739241157067824416245546374568847937204678288252116089080688173934638564031950544806463980467254757125934359394683198190255474629179266277601987023393543376811412693043039558487983367289
phi1 = 125152237161980107859596658891851084232065907177682165993300073587653109353529564397637482758441209445085460664497151026134819384539887509146955251284230125943565148141498300205893475242956903188936949934637477735897301870046234768439825644866543391610507164360506843171701976641285249754264159339017466738250
phi2 = 125152237161980107859596658891851084232065907177682165993300073587653109353529564397637482758441209445085460664497151026134819384539887509146955251284230123577760657520479879758538312798938234126141096433998438004751495264208294710150161381066757910797946636886901614307738041629014360829994204066455759806614

s = Solver()

p = Int("p")
q = Int("q")

s.add(p*q == n)
s.add((p-2)*(q-1) == phi1)
s.add((p-1)*(q-2) == phi2)

assert s.check() == sat
print(s.model())
```

It takes only a few second to do it, and should print us the number of p and q